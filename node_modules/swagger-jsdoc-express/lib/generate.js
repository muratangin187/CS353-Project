"use strict";
/**
 * This file is part of the swagger-jsdoc-express distribution.
 * Copyright (c) e.GO Digital GmbH, Aachen, Germany (https://www.e-go-digital.com/)
 *
 * swagger-jsdoc-express is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * swagger-jsdoc-express is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSwaggerV2Document = void 0;
const _ = require("lodash");
const deepMerge = require("deepmerge");
const utils_1 = require("./utils");
/**
 * Generates a Swagger V2 document.
 *
 * @param {SwaggerV2DocBlock|SwaggerV2DocBlock[]} blocks One or more blocks.
 * @param {GenerateSwaggerV2DocumentOptions} [opts] Custom, optional options.
 *
 * @return {SwaggerV2Document} The generated document.
 */
function generateSwaggerV2Document(blocks, opts) {
    if (_.isNil(opts)) {
        opts = {};
    }
    blocks = utils_1.asArray(blocks);
    const PATH_BLOCKS = blocks.filter(b => {
        return 'path' === utils_1.normalizeString(b.type);
    });
    const DEFINITION_BLOCKS = blocks.filter(b => {
        return 'definition' === utils_1.normalizeString(b.type);
    });
    const SCHEMES = utils_1.asArray(opts.schemes)
        .map(s => utils_1.normalizeString(s))
        .filter(s => '' !== s);
    const DOC = {
        'swagger': '2.0',
        'info': _.isNil(opts.info) ? undefined : opts.info,
        'host': utils_1.isEmptyString(opts.host) ? undefined : utils_1.toStringSafe(opts.host).trim(),
        'tags': _.isNil(opts.tags) ? undefined : [],
        'schemes': SCHEMES.length ? SCHEMES : undefined,
        'paths': PATH_BLOCKS.length ? {} : undefined,
        'definitions': DEFINITION_BLOCKS.length ? {} : undefined,
        'externalDocs': _.isNil(opts.externalDocs) ? undefined : opts.externalDocs,
        'basePath': utils_1.isEmptyString(opts.basePath) ? undefined : utils_1.toStringSafe(opts.basePath),
        'securityDefinitions': _.isNil(opts.securityDefinitions) ? undefined : opts.securityDefinitions,
    };
    // tags
    if (!_.isNil(opts.tags)) {
        for (const TAG_NAME of Object.keys(opts.tags).sort((x, y) => utils_1.compareValuesBy(x, y, i => utils_1.normalizeString(i)))) {
            DOC.tags.push({
                'name': TAG_NAME,
                'description': utils_1.toStringSafe(opts.tags[TAG_NAME]),
            });
        }
    }
    // paths
    if (PATH_BLOCKS.length) {
        for (const PB of PATH_BLOCKS) {
            if (!PB.details) {
                continue;
            }
            for (const DETAILS_PROP in PB.details) {
                const PATH_PROP = DETAILS_PROP.trim();
                if (_.isNil(DOC.paths[PATH_PROP])) {
                    DOC.paths[PATH_PROP] = {};
                }
                DOC.paths[PATH_PROP] = utils_1.sortObjectByKey(deepMerge(DOC.paths[PATH_PROP], PB.details[DETAILS_PROP]));
            }
        }
        DOC.paths = utils_1.sortObjectByKey(DOC.paths);
    }
    // definitions
    if (DEFINITION_BLOCKS.length) {
        for (const DB of DEFINITION_BLOCKS) {
            if (!DB.details) {
                continue;
            }
            for (const DEF_NAME in DB.details) {
                DOC.definitions[DEF_NAME.trim()] = DB.details[DEF_NAME];
            }
        }
        DOC.definitions = utils_1.sortObjectByKey(DOC.definitions);
    }
    // we need a "clean" plain object here
    return JSON.parse(JSON.stringify(DOC));
}
exports.generateSwaggerV2Document = generateSwaggerV2Document;
//# sourceMappingURL=generate.js.map